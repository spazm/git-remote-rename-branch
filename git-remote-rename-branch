#!perl
use v5.26.0;
use feature 'signatures';

use Data::Dumper;
use Digest::SHA1 qw(sha1);
use FileHandle;
use Getopt::Long;
use IPC::Open2;
use IPC::Open3;
use Net::SSH;
use POSIX qw(:sys_wait_h);

no warnings "experimental::signatures";

my $BUFFER_READ_SIZE = 4096;
my $EMPTY_SHA = "0" x 40;
# PACK file, version 2, 0 objects + 20 byte sha1 checksum
my $EMPTY_PACK = pack("A4NN", "PACK", 2, 0);
$EMPTY_PACK .= sha1($EMPTY_PACK);
my $GIT_RECEIVE_PACK = "git-receive-pack";

my $SSH_DIED = 0;
$SIG{'PIPE'} = sub {
  $SSH_DIED = 1;
  say STDERR "SSH process died";
};

sub format_line($line, $sidechannel=0) {
  # packet_line format requires a 4 byte header containing the length of the header + line.
  # newlines are not required at the end of lines, but if included they must be included in the length
  # 0004 empty message is not allowed
  # 0000 is a special packet_sync message.
  # convert empty $line into packet_sync.
  # If using sidechannel, an additional byte is included after the header to indicate which sidechannel
  my $len = length($line);
  $len += 4 if $len;
  if ($sidechannel) {
    sprintf("%04X%s%s", $len + 1, $sidechannel, $line)
  } else {
    sprintf("%04X%s", $len, $line)
  }
}

sub get_branch_sha($remote, $old, $new) {
  # Use git ls-remote to retrieve branch information from repository
  # return a hashref of fully qualified branch (refs/heads/$branch) to sha
  my $branch_sha = {};
  open(my $ls_remote, '-|', "git ls-remote $remote $old $new")
    || die "git ls-remote failed for remote$remote\n";

  while(my $line = <$ls_remote>) {
    my ($sha, $branch) = split(/\s+/, $line);
    $branch_sha->{$branch} = $sha;
  }
  $branch_sha;
}

my $DEBUG = 1;
sub dsay {
  say STDERR @_ if $DEBUG;
}

sub usage {
  my $error = shift;
  my $usage .= <<"EOF";
    Usage:
      ./git rename-remote-branch REMOTE
      ./git rename-remote-branch REMOTE [OLD] NEW

      renames OLD to NEW.
      OLD defaults to 'master'
      NEW defaults to 'main'
EOF
  $usage .= "\n\nfatal: $error\n" if $error;
  die($usage);
}

sub parse_args {
  usage("REMOTE is required") unless @ARGV;
  usage("Too many arguments") if @ARGV > 3;
  my $old = "master";
  my $new = "main";
  my $remote = shift @ARGV;
  $new       = pop   @ARGV if @ARGV;
  $old       = shift @ARGV if @ARGV;

  $old =~ s,refs/heads/,,;
  $new =~ s,refs/heads/,,;
  usage("OLD and NEW must be different names") if $old eq $new;
  ($remote, $old, $new);
}

sub read_io_buffer($io, $delay=10) {
  my $buffer = "";
  my $tmp_buffer = "";
  my $done = 0;
  while (not $done and my @ready = $io->can_read($delay))  {
    $delay = 1;
    for my $reader (@ready) {
      my $bytes_read = sysread($reader, $tmp_buffer, $BUFFER_READ_SIZE);
      dsay "    read_buffer: read $bytes_read from reader:$reader partial_buffer:[$tmp_buffer]";
      $buffer .= $tmp_buffer;
      $done = 1 if not defined($bytes_read) or $bytes_read == 0;
    }
  }
  return $buffer;
}

sub main {
  my ($remote, $old, $new) = parse_args();
  dsay "Renaming $old to $new";
  dsay "  on remote: $remote";

  my $branch_sha = get_branch_sha($remote, $old, $new);
  my $old_sha = $branch_sha->{"refs/heads/$old"};
  my $new_sha = $branch_sha->{"refs/heads/$new"};

  die "already complete\n" if !$old_sha and $new_sha;
  die "$old does not exist in remote\n" unless $old_sha;
  die "$new already exists in remote\n" if $new_sha;

  dsay "  $old has sha: $old_sha";

  do_it($remote, $old, $new, $old_sha);
  #do_it_ipc_run($remote, $old, $new, $old_sha);
  dsay "end main";
}

sub do_it($remote, $old, $new, $old_sha){
  my $cmd = rename_remote_branch_command($old, $new, $old_sha);
  # dsay "cmd: [$cmd]";

  # dsay "send to ssh";
  #TODO: check remote for real
  my ($user_host, $path) = split(':', $remote);
  die "repository name is required\n" unless defined $path;
  $path .= '.git' unless $path =~ m/.git$/;
  dsay "  connecting to host: $user_host";

  my @ssh_cmd = ("ssh", '-x', $user_host,  $GIT_RECEIVE_PACK, "'$path'");
  #my @ssh_cmd = ("ssh", $user_host,  $GIT_RECEIVE_PACK, "'$path'");
  dsay "ssh_cmd: @ssh_cmd";
  my $rh = FileHandle->new();
  my $wh = FileHandle->new();
  my $eh = FileHandle->new();
  #$rh->autoflush(0);
  #$wh->autoflush(1);
  #$eh->autoflush(1);
  binmode($rh);
  binmode($wh);
  binmode($eh);

  my $pid = open3($wh, $rh, $eh, @ssh_cmd);
  my $io = IO::Select->new($rh, $wh);
  my $io_err = IO::Select->new($eh);

  # read initial message from buffer.
  my $initial_msg = read_io_buffer($io, 10);
  dsay "initial_sysread: $initial_msg";

  dsay "checking for errors";
  my $error_msg = read_io_buffer($io_err, 1);
  if (waitpid($pid, WNOHANG)) {
    die($error_msg);
  }

  dsay("sending cmd to ssh. length:" . length($cmd));
  if (my @ready = $io->can_write(10)){
    dsay "clear to send";
    my $bytes_read = syswrite($ready[0], $cmd);
    if (defined($bytes_read)) {
      dsay "success: wrote $bytes_read bytes";
    } else {
      die("write failed: $!\n");
    }
  }

  dsay("reading response from ssh.");
  my $server_response = read_io_buffer($io, 10);
  dsay "server_response sysread: [$server_response]";
  dsay "close write handle";
  close($wh);
  dsay "wait pid";
  waitpid($pid, 0);
  dsay "end doit";
}

sub rename_main_to_master($sha) {
  rename_remote_branch('master', 'main', $sha);
}


sub rename_remote_branch($old, $new, $sha) {
  my $cmd = rename_remote_branch_command($old, $new, $sha);
}

sub rename_remote_branch_command($old, $new, $sha) {
  my ($new_ref, $old_ref) = map "refs/heads/$_", ($new, $old);
  #my $options = "\0 report-status side-band-64k agent=git/2.17.1";
  my $options = "\0 report-status agent=git/2.17.1";

  # git-receive-pack message format:
  #   OLD_SHA NEW_SHA BRANCH\0OPTIONS
  #   OLD_SHA NEW_SHA BRANCH
  #   OLD_SHA NEW_SHA BRANCH
  #   SYNC_PACKET
  #   PACKFILE

  # delete old_ref by setting NEW_SHA to EMPTY
  # create new_ref by setting OLD_SHA to EMPTY
  my $cmd = format_line("$sha $EMPTY_SHA $old_ref$options\n") .
            format_line("$EMPTY_SHA $sha $new_ref\n") .
            format_line("") .
            $EMPTY_PACK
            ;
}

main();
